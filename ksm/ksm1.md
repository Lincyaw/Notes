---
sort: 5
---

# KSM 相关资料

## [文章一](https://lwn.net/Articles/306704/) 翻译

内核通常不遗余力地在进程之间共享相同的内存页。例如，程序段（program text）总是被共享的。但是，当内核知道内存的内容对所有参与的进程都是相同的时候，可写页也会在进程之间共享。当一个进程调用fork()时，所有的可写页都变成了写时复制（COW）页，并在父进程和子进程之间共享。只要两个进程都没有修改任何特定页面的内容，这种共享就可以继续下去，并相应地减少内存的使用。

使用 fork() 的写时复制之所以有效，是因为内核知道每个进程都希望在这些页面中找到相同的内容。但是，当内核缺乏这种知识时，它通常无法安排共享相同的页面。人们可能认为这通常不是一个问题，但是KVM的开发者已经想出了一些可能出现这种共享机会的情况。你的编辑无法抗拒Avi Kivity提出的[这个案例](https://lwn.net/Articles/306706/)。

> 考虑一下典型的多用户gnome小型计算机，所有150个用户都在同时阅读lwn.net而不是工作。你可以共享firefox的渲染页面缓存，大大降低内存利用率。

不过，除了这些典型的系统之外，考虑一下主机运行一些虚拟化的客户的情况。这些客人不会共享一个进程树关系，这使得他们之间共享页面很容易，但他们很可能使用相当一部分内存来保存相同的内容。如果该主机能够找到一种方法来强制共享具有相同内容的页面，它应该能够更好地利用其内存，并因此而运行更多的客户。这是一种能够引起虚拟化开发者注意的事情。因此，Qumranet Red Hat的黑客们（特别是Izik Eidus、Andrea Arcanageli和Chris Wright）已经把一种机制放在一起，使这种共享发生。由此产生的代码被称为KSM，最近被[po](https://lwn.net/Articles/306642/)出来供更多人审查。

KSM以设备驱动程序的形式出现在一个单一的虚拟设备上：/dev/ksm。一个想要参与页面共享机制的进程可以打开该设备，并（通过ioctl()调用）将其地址空间的一部分注册给KSM驱动。一旦页面共享机制被打开（通过另一个ioctl()），内核将开始寻找要共享的页面。

该算法相对简单。KSM驱动，在一个内核线程中，选择一个在它那里注册的内存区域并开始扫描它。对于每个驻留在内存中的页面，KSM将生成该页面内容的SHA1哈希值。然后这个哈希值将被用来查找具有相同哈希值的其他页面。如果随后的memcmp()调用显示这些页面的内容确实是相同的，那么所有对被扫描页面的引用的进程将被指向（在COW模式下）另一个页面，而多余的页面将被退回给系统。只要没有人修改该页，共享就可以继续；一旦有写操作发生，该页就会被复制，共享就会结束。

内核线程在进入睡眠状态之前会扫描到最多的页数。扫描的页数和睡眠时间都是作为参数传递给开始扫描的ioctl()调用。用户空间的控制进程也可以通过另一个ioctl()调用来暂停扫描。

Andrew Morton对该补丁的[最初反应](https://lwn.net/Articles/306710/)并不完全是热情的。

> 整个方法在我看来是错误的。内核失去了对这些页面的追踪，然后我们又在事后试图修复它。请解释一下（在更新日志中），为什么内核不能通过通常的共享、反计数和COWing方法来解决这个问题。

Avi Kivity的[回答](https://lwn.net/Articles/306711/)相当明确。

> 对于kvm来说，内核从来不知道这些页面是共享的。它们是从独立的（可能是压缩的和加密的）磁盘镜像中加载的。这些镜像是不同的；但有些页面碰巧是相同的，因为它们来自同一个安装媒体。

Izik Eidus 补充说，通过这个补丁，运行一堆 Windows 客户机的主机能够超额使用其内存 300%，而不会产生严重的不良影响。这种技术似乎对 Windows 客户机特别有效：Windows 显然将所有释放的内存归零，因此每个客户机的空闲页面列表都可以合并为一个完整的零共享页面。

尚未完成（或至少未发布）的是 KSM 对正在运行的系统的影响的任何形式的基准测试。页面的扫描、散列和比较将需要一些 CPU 时间，并且可能也会产生明显的缓存效果。如果您尝试运行数十个 Windows 客户机，缓存效果在您的问题列表中可能相对较低。但该成本可能足以阻止更广泛地使用 KSM，即使根本不使用虚拟化的系统可能仍然有很多具有相同内容的页面。

## [文章二](https://lwn.net/Articles/330589/)


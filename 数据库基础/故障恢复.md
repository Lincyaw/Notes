---
sort: 10
---
# 故障恢复

## 三种类型的故障

- 三种类型的故障
	- 事务故障
		- 某个事务自身运行错误引起的故障
	- 系统故障
		- 掉电、非正常关机引起的故障
	- 介质故障
		- 介质损坏

## 三种恢复手段

- 事务的撤销与重做
- 运行日志
	- 有了日志可以实现事务的redo和undo
- 备份

## 两个重要时刻

- 检查点

	- 保障检查点之前的内存数据和介质数据是一致的

	检查点又分为**静止检查点**和**非静止检查点**。

	- **静止检查点：周期性地对日志设置检查点**，停止接受新的事务，等到当前所有活跃事务提交或者终止并且在日志中写入commit或abort后，将日志刷盘
	- **非静止检查点**，允许新事务进入。很明显，此时的检查点将是一个区间。

	<img src="%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.assets/image-20210501154446175.png" alt="image-20210501154446175" style="zoom: 67%;" />

	start点有一些事务还没有结束，此时维护一个尚未结束的事务的集合。当事务结束时，将事务踢出这个集合；有新的事务进来时，加入这个集合。当这个集合为空的时候，就到了end点。

	但有一个非常明显的问题是，这个区间可能非常的长，甚至永远找不到一个结束的点。

- 转储点 **replicas**

	- 这个时刻产生备份

	![image-20210501155134778](%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.assets/image-20210501155134778.png)

## 四个缓冲区处理策略

![image-20210501153837882](%E6%95%85%E9%9A%9C%E6%81%A2%E5%A4%8D.assets/image-20210501153837882.png)

- Force
	- 内存中的数据最晚在commit的时候写入磁盘。
- Steal
	- **允许在commit之前就把内存的数据写入磁盘，那么显然，如果abort了，那就要undo这些操作**
- No force
	- **内存中的数据可以在commit之后再写入磁盘，那么，如果abort了，有些操作已经写入磁盘了，有些还没有写，那就要redo这些所有的操作**
- No steal
	- 不允许在事务commit之前把内存中的数据写入磁盘。

## 三种类型的日志

- UNDO，**先output再commit**
	- **将事务改变的所有数据写到磁**盘**前不能提交该事务，日志中仅保留旧值
	- 步骤：
		- 首先，<T, X, v>被写到日志中
		- 其次，OUTPUT(X)
		- 最后，`<COMMIT T>`或`<ABORT T>`被写到日志中
- REDO，**先commit再output**
	- 将事务改变的所有的值全部**写到日志**之前不能提交该事务，日志中仅保留新值。
	- 步骤
		- 首先，<T, X, v>被写到日志中
		- 其次，`<COMMIT T>`被写到日志中
		- 最后，OUTPUT(X)
- 两者结合
	- 步骤
		- commit之前之后都能output数据，也就意味着
		- 如果abort，他要undo已经写的东西；
		- 如果commit之前崩溃了，他要undo；
		- 如果commit之后崩溃了，他要先undo，再redo；


---
sort: 5
---
# 规范化理论

## 基本概念

Y 函数依赖 X == X 函数决定 Y，函数依赖表示 **一个X能够唯一确定一个Y**。

符号表示为：X->Y

```note
例如：
- 身份证能够唯一确认一个人
- {学号，课程号}能够唯一确认一个人的成绩
```

```note
### 非平凡的函数依赖
X 函数决定 Y，但 不属于 X 的一部分

例如：
- {学号，课程号}能够唯一确认学号，这样并不是**非平凡的函数依赖**
```

```note
### 完全函数依赖以及部分函数依赖
X 是能够决定 Y 的所有集合中的最小子集，则称为完全函数依赖；否则叫做部分函数依赖

例如：
- {学号，课程号}能够唯一确认一个人的成绩，任意去掉“学号”或者“课程号”，都无法再确认一个人的成绩，则称 X完全函数决定 Y
```

具有这种特点的属性，就可以作为主键。{学号，课程号}可被称为联合主键。

```note
### 传递函数依赖
X->Y && Y->Z && Y 不是 X 的一部分 && Z 不是 X和Y 的一部分 && Y!->X

前几个条件可以理解，即确保不存在**平凡函数依赖**，但`Y!->X`意味着什么呢？

假设 Y->X，则此时的依赖图如下：让我们把这个问题留到后面来解答
![image-20210503152801860](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503152801860.png)
```

```note
### 候选键
上面提到了完全函数依赖，X就是候选键。
- 可以任选一个候选键作为R(relationship)的主键
- 包含在任一候选键中的属性称主属性(Prime Attribute),其他属性称非主属性；
- 如果X是候选键，而S包含了X，则称S为超键（S包含了冗余的信息）
```

```note
### 逻辑蕴含
F 是关系模式 R(U) 的函数依赖集，X 和 Y 是 R 的属性自己，如果 F 中的函数依赖们能够推导出 `X->Y`， 则称 F 逻辑蕴含`X->Y`。

注意：这里并没有提到 F 中原来是否包含着`X->Y`。如果能够推导的话，非常直观的一种方式就是通过链式推导出来，但这样的结果就出现了上面提到的**传递函数依赖**
```

```note
### 闭包
由逻辑蕴含的函数依赖集 F **升级**而来。闭包是所有**函数依赖集的集合**，记作F+。

如果F==F+，则叫他全函数依赖族（函数依赖完备集）
```

到这里再不放点图，就要晕了。

![image-20210503155657363](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503155657363.png)

```tip
注解：
- 从F中可以看到，A是爷爷。X只要包含了爷爷，Y无论取什么，X和Y都可以构成函数依赖，这样的集合就是(1)
- B是爸爸，那么只要Y不包含爷爷，X和Y还可以构成函数依赖集
- X不能取爷爷和爸爸，那么X和Y只能都是孙子才能构成函数依赖集了

plus：只要Y连孙子都不是（空集），那么也可以构成函数依赖集。

这样的函数依赖集的集合叫做闭包。
```

```note
### 覆盖
开始对闭包下手了。如果两个函数依赖集F、G，他们的闭包是相等的，那么称 F 和 G 是等价的，也称为 F 覆盖 G，或 G 覆盖 F。
```

![image-20210503161040753](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503161040753.png)

```
### 最小覆盖解释
F: 函数依赖集
- 2）中，X->A 是 F 中的一个函数依赖，如果去掉 X->A，则剩下的集合应当与F不一样。否则 X->A 就是冗余的信息，可以去掉。
- 3）中，Z 是 X 中的一个元素，F-{X->A} 并上 Z->A 如果等价于 F，就意味着 Z 一个元素就可以代替 X 中所有元素的作用，意味着 X 中的信息还是有冗余。
```

可以发现，上面的非常多的定义都是为了达成一个目的：**减少信息冗余**。

---

计算闭包的算法：

![image-20210503161928061](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503161928061.png)

## 函数依赖的公理和定理

自反律、增广律、传递律、合并律、伪传递律、分解律...

没必要看


---
sort: 5
---
# 规范化理论

## 基本概念

Y 函数依赖 X == X 函数决定 Y，函数依赖表示 **一个X能够唯一确定一个Y**。

符号表示为：X->Y

```note
例如：
- 身份证能够唯一确认一个人
- {学号，课程号}能够唯一确认一个人的成绩
```

```note
### 非平凡的函数依赖
X 函数决定 Y，但 不属于 X 的一部分

例如：
- {学号，课程号}能够唯一确认学号，这样并不是**非平凡的函数依赖**
```

```note
### 完全函数依赖以及部分函数依赖
X 是能够决定 Y 的所有集合中的最小子集，则称为完全函数依赖；否则叫做部分函数依赖

例如：
- {学号，课程号}能够唯一确认一个人的成绩，任意去掉“学号”或者“课程号”，都无法再确认一个人的成绩，则称 X完全函数决定 Y
```

具有这种特点的属性，就可以作为主键。{学号，课程号}可被称为联合主键。

```note
### 传递函数依赖
X->Y && Y->Z && Y 不是 X 的一部分 && Z 不是 X和Y 的一部分 && Y!->X

前几个条件可以理解，即确保不存在**平凡函数依赖**，但`Y!->X`意味着什么呢？

假设 Y->X，则此时的依赖图如下：让我们把这个问题留到后面来解答
![image-20210503152801860](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503152801860.png)
```

```note
### 候选键
上面提到了完全函数依赖，X就是候选键。
- 可以任选一个候选键作为R(relationship)的主键
- 包含在任一候选键中的属性称主属性(Prime Attribute),其他属性称非主属性；
- 如果X是候选键，而S包含了X，则称S为超键（S包含了冗余的信息）
```

```note
### 逻辑蕴含
F 是关系模式 R(U) 的函数依赖集，X 和 Y 是 R 的属性自己，如果 F 中的函数依赖们能够推导出 `X->Y`， 则称 F 逻辑蕴含`X->Y`。

注意：这里并没有提到 F 中原来是否包含着`X->Y`。如果能够推导的话，非常直观的一种方式就是通过链式推导出来，但这样的结果就出现了上面提到的**传递函数依赖**
```

```note
### 闭包
由逻辑蕴含的函数依赖集 F **升级**而来。闭包是所有**函数依赖集的集合**，记作F+。

如果F==F+，则叫他全函数依赖族（函数依赖完备集）
```

到这里再不放点图，就要晕了。

![image-20210503155657363](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503155657363.png)

```tip
注解：
- 从F中可以看到，A是爷爷。X只要包含了爷爷，Y无论取什么，X和Y都可以构成函数依赖，这样的集合就是(1)
- B是爸爸，那么只要Y不包含爷爷，X和Y还可以构成函数依赖集
- X不能取爷爷和爸爸，那么X和Y只能都是孙子才能构成函数依赖集了

plus：只要Y连孙子都不是（空集），那么也可以构成函数依赖集。

这样的函数依赖集的集合叫做闭包。
```

```note
### 覆盖
开始对闭包下手了。如果两个函数依赖集F、G，他们的闭包是相等的，那么称 F 和 G 是等价的，也称为 F 覆盖 G，或 G 覆盖 F。
```

![image-20210503161040753](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503161040753.png)

```
### 最小覆盖解释
F: 函数依赖集
- 2）中，X->A 是 F 中的一个函数依赖，如果去掉 X->A，则剩下的集合应当与F不一样。否则 X->A 就是冗余的信息，可以去掉。
- 3）中，Z 是 X 中的一个元素，F-{X->A} 并上 Z->A 如果等价于 F，就意味着 Z 一个元素就可以代替 X 中所有元素的作用，意味着 X 中的信息还是有冗余。
```

可以发现，上面的非常多的定义都是为了达成一个目的：**减少信息冗余**。

---

计算闭包的算法：

![image-20210503161928061](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503161928061.png)

## 函数依赖的公理和定理

自反律、增广律、传递律、合并律、伪传递律、分解律...

没必要看



## 范式

一个我认为非常好的[对于范式的解释](https://zhuanlan.zhihu.com/p/20028672?ivk_sa=1024320u)。下面总结一下几个范式的定义及其特点。

一个用来理解这些范式的比较好的方法是问问自己：

- 为什么有这个范式，这个范式解决了什么问题？
- 这个范式还有什么缺点？

> 在任意一个需要被研究的方向中都可以提出这样的问题：
>
> - 这个领域存在着什么问题？
> - （我）提出的这个方法是什么？解决了什么问题？
> - （我）是怎么实现这个方法的？
> - 这个方法要怎么用？
> - 这个方法还有什么缺点？

### 第一范式

```note
一个关系中的每个属性不可分。1NF是所有关系型数据库的最基本要求。

例如：
- 地点，仍然可以分为国家、省市区街道，因此应当将这些属性分开
```

### 第二范式

问：第一范式有什么问题？
- 数据冗余
- 插入异常
- 删除异常
- 修改异常

> 怎么记？增改删+冗余

![img](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/@YO$%250OH%5DFIO%5BCT24PM5TY.png)

**数据冗余**：每一名学生的学号、姓名、系名、系主任这些数据重复多次。每个系与对应的系主任的数据也重复多次

**插入异常**：假如学校新建了一个系，但是暂时还没有招收任何学生（比如3月份就新建了，但要等到8月份才招生），那么是无法将系名与系主任的数据单独地添加到数据表中去的 *（注１）*

```tip
注1：

根据三种关系完整性约束中实体完整性的要求，关系中的码（注２）所包含的任意一个属性都不能为空，所有属性的组合也不能重复。为了满足此要求，图中的表，只能将学号与课名的组合作为码，否则就无法唯一地区分每一条记录。

注2：
码：关系中的某个属性或者某几个属性的组合，用于区分每个元组（可以把“元组”理解为一张表中的每条记录，也就是每一行）。
```

**删除异常**：假如将某个系中所有学生相关的记录都删除，那么所有系与系主任的数据也就随之消失了（一个系所有学生都没有了，并不表示这个系就没有了）。

**修改异常**：假如李小明转系到法律系，那么为了保证数据库中数据的一致性，需要修改三条记录中系与系主任的数据

```note
#### 定义
如果关系已经是1NF的基础上，如果每个**非主属性完全函数依赖于候选键**，则称该关系属于第二范式。

即：2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。
```

问：怎么判断是否是2NF？

1. 找出数据表中所有的**码**。
2. 根据第一步所得到的码，找出所有的**主属性**。
3. 数据表中，除去所有的主属性，剩下的就都是**非主属性**了。
4. 查看是否存在非主属性对码的**部分函数依赖**。

思考`{学号、课名、姓名、系名、分数、系主任}`之间的关系。根据上面的4个步骤，我们可以这样做：

1. 查看所有每一单个属性，当它的值确定了，是否剩下的所有属性值都能确定。
2. 查看所有包含有两个属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。
3. ……
4. 查看所有包含了六个属性，也就是所有属性的属性组，当它的值确定了，是否剩下的所有属性值都能确定。

>  有一个方法是假如A是码，那么所有包含了A的属性组，如（A，B）、（A，C）、（A，B，C）等等，都不是码(候选码)了（因为作为码的要求里有一个“**完全**函数依赖”）。

结果为：

1. 码只有一个，就是**（学号、课名）**，通过这个码可以唯一确定任意的一条元组（可以唯一确定分数、姓名、系名、系主任）
2. 主属性有两个：**学号** 与 **课名**
3. 非主属性有四个：**姓名**、**系名**、**系主任**、**分数**
4. 对于**（学号，课名） → 姓名**，有 **学号 → 姓名**，存在非主属性 **姓名** 对码**（学号，课名）**的部分函数依赖。
	对于**（学号，课名） → 系名**，有 **学号 → 系名**，存在非主属性 系**名** 对码**（学号，课名）**的部分函数依赖。
	对于**（学号，课名） → 系主任**，有 **学号 → 系主任**，存在非主属性 对码**（学号，课名）**的部分函数依赖。

![img](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/51e2689ac9416a91800e63101bee9db7_720w.jpg)



#### 解决方案：模式分解，俗称拆表

拆成两个表：

- 选课（学号，课名，分数）
- 学生（学号，姓名，系名，系主任）

对于**选课**表，其码是**（学号，课名）**，主属性是**学号**和**课名**，非主属性是**分数**，**学号**确定，并不能唯一确定**分数**，**课名**确定，也不能唯一确定**分数**，所以不存在非主属性**分数**对于码 **（学号，课名）**的部分函数依赖，所以此表符合2NF的要求。

对于**学生**表，其码是**学号，**主属性是**学号**，非主属性是**姓名、系名**和**系主任**，因为码只有一个属性，所以不可能存在非主属性对于码 的部分函数依赖，所以此表符合2NF的要求。

![img](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/2f4b4a887f6a61674a49d03d79e3fe17_720w.jpg)

#### 解决了什么问题

```note
- 李小明转系到法律系
	- 只需要修改一次李小明对应的系的值即可。——修改异常，有改进
- 数据冗余是否减少了？
	- 学生的姓名、系名与系主任，不再像之前一样重复那么多次了。——数据冗余，有改进
- 删除某个系中所有的学生记录
	- 该系的信息仍然全部丢失。——删除异常，无改进
- 插入一个尚无学生的新系的信息。
	- 因为学生表的码是学号，不能为空，所以此操作不被允许。——插入异常，无改进
```

### 第三范式

**3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖**。也就是说， 如果存在非主属性对于码的传递函数依赖，则不符合3NF的要求。

看看上面两个表是否符合3NF：

- 对于**选课**表，主码为（学号，课名），主属性为**学号**和**课名，**非主属性只有一个，为分数，不可能存在传递函数依赖，所以**选课**表的设计，符合3NF的要求。
- 对于**学生**表，主码为**学号**，主属性为**学号**，非主属性为**姓名**、**系名**和**系主任**。因为 学号 → 系名，同时 系名 → 系主任，所以存在非主属性**系主任**对于码**学号**的传递函数依赖，所以**学生**表的设计，不符合3NF的要求。

继续分解：

- 选课（学号，课名，分数）
- 学生（学号，姓名，系名）
- 系（系名，系主任）

对于**学生**表，码为**学号**，主属性为**学号**，非主属性为**系名**，不可能存在非主属性对于码的传递函数依赖，所以符合3NF的要求。

对于**系**表，码为**系名**，主属性为**系名**，非主属性为**系主任**，不可能存在非主属性对于码的传递函数依赖（至少要有三个属性才可能存在传递函数依赖关系），所以符合3NF的要求。

![img](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/5b20707ff3d9afb51ef7bfda726c3e34_720w.jpg)

#### 解决了什么问题

```note
- 删除某个系中所有的学生记录
	- 该系的信息不会丢失。——删除异常，有改进
- 插入一个尚无学生的新系的信息。
	- 因为系表与学生表目前是独立的两张表，所以不影响。——插入异常，有改进
- 数据冗余更加少了。——数据冗余，有改进
```

3NF继续改进了2NF，把2NF没能解决的**删除异常**和**插入异常**解决了。

#### 仍有什么问题？

若：

1. 某公司有若干个仓库；
2. 每个仓库只能有一名管理员，一名管理员只能在一个仓库中工作；
3. 一个仓库中可以存放多种物品，一种物品也可以存放在不同的仓库中。每种物品在每个仓库中都有对应的数量。

那么关系模式 仓库（仓库名，管理员，物品名，数量） 属于哪一级范式？

答：

- 已知函数依赖集：仓库名 → 管理员，管理员 → 仓库名，（仓库名，物品名）→ 数量
- 码：（管理员，物品名），（仓库名，物品名）
- 主属性：仓库名、管理员、物品名
- 非主属性：数量
	∵ 不存在非主属性对码的部分函数依赖和传递函数依赖。∴ 此关系模式属于3NF。

基于此关系模式的关系（具体的数据）可能如图所示：

![img](https://pic3.zhimg.com/80/68d080d437732aad8cfe451b427849d6_720w.jpg)



好，既然此关系模式已经属于了 3NF，那么这个关系模式是否存在问题呢？我们来看以下几种操作：

1. 先新增加一个仓库，但尚未存放任何物品，是否可以为该仓库指派管理员？——不可以，因为物品名也是主属性，根据实体完整性的要求，主属性不能为空。
2. 某仓库被清空后，需要删除所有与这个仓库相关的物品存放记录，会带来什么问题？——仓库本身与管理员的信息也被随之删除了。
3. 如果某仓库更换了管理员，会带来什么问题？——这个仓库有几条物品存放记录，就要修改多少次管理员信息。

从这里我们可以得出结论，在某些特殊情况下，即使关系模式符合 3NF 的要求，仍然存在着**插入异常**，**修改异常**与**删除异常**的问题，仍然不是 ”好“ 的设计。

造成此问题的原因：存在着**主属性**对于码的部分函数依赖与传递函数依赖。

>  （在此例中就是存在主属性【仓库名】对于码【（管理员，物品名）】的部分函数依赖。

解决办法就是要在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

- 仓库（仓库名，管理员）
- 库存（仓库名，物品名，数量）

这样，之前的插入异常，修改异常与删除异常的问题就被解决了。

#### BCNF

在 3NF 的基础上消除**主属性**对于码的部分与传递函数依赖。

![image-20210503173702259](%E8%A7%84%E8%8C%83%E5%8C%96%E7%90%86%E8%AE%BA.assets/image-20210503173702259.png)

## 模式分解

### 问题

### 无损连接分解

### 保持连接分解
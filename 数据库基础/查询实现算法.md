---
sort: 8
---
# 查询实现算法及其优化

**没有什么重点**

## 符号约定

![image-20210501155539579](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501155539579.png)

这一块的重点在于理解物理层面上的查询代价。

## 连接操作的实现

### 基本实现算法

只需要3块内存，复杂度高，每读一块block就要io一次，因此需要Br+Br*Rs次io

一块装R，一块装S，一块输出。

```python
while R 没读完
	读一块R
	while S 没读完
		读一块S
		if R能和S连接
			输出到缓冲区
            写磁盘
```

### 全主存实现算法

要求内存能够完全装下两个关系，因此需要 Br+Rs次io

```python
全部读R和S
while R 没读完
	while S 没读完
		if R能和S连接
			输出到缓冲区
            写磁盘
```



### 半主存实现算法

要求能装下一个关系，因此还是Br+Rs次io

```python
全部读R
while R 没读完
	while S 没读完
		读一块S
		if R能和S连接
			输出到缓冲区
            写磁盘
```



### 大关系实现算法

前提假设：$B_s>=B_R, B_R<M$

把S按`M-2`的数量划分为不同的子集，M为内存能放的磁盘块个数，剩下的，一块用来放R，一块用来输出。

所以外层循环是读S，要循环S/(M-2)次，内层循环读R,记录读R的次数是`(Bs/(M-2))Br`，外层本身还读了一个S，因此总io次数为`(Bs/(M-2))Br+Bs`

```python
将S分成Bs/(M-2)组
while S 没读完
	读一组S（一组S有M-2块）
	while R 没读完
    	读一块R
		if R能和S连接
			输出到缓冲区
            写磁盘
```

## 表扫描算法

没有什么重点，只要记住排序需要`2B(R)`即可。

> 那么，为什么排序需要2B(R)呢？

![image-20210501164429648](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164429648.png)

## 去重

![image-20210501164521285](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164521285.png)

## 分组聚集

![image-20210501164538421](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164538421.png)

## 交、并、差

![image-20210501164608604](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164608604.png)

## 基于索引的选择

![image-20210501164711093](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164711093.png)

![image-20210501164721290](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164721290.png)

## 基于索引的连接

![image-20210501164744158](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501164744158.png)

# 优化

怎么优化呢？

![image-20210501170837033](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501170837033.png)

宗旨：

1. 把WHERE($\sigma_{F1 \and F2 \and F3...}$)的条件尽量地拆开，串行化
2. 尽量把投影（select）操作先做了

目的就是为了让生成的中间表越小越好。

![image-20210501171233152](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501171233152.png)

## 代价估算

![image-20210501171310523](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501171310523.png)

目的是估算以上统计信息中的值。

### 经验方法

![image-20210501172017778](%E6%9F%A5%E8%AF%A2%E5%AE%9E%E7%8E%B0%E7%AE%97%E6%B3%95.assets/image-20210501172017778.png)
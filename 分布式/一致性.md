# 一致性
为了提高分布式系统的可用性，有很多手段。数据复制是其中一种。

在多副本的情况下：
- 如果一台服务器不可用了，就可以切换到其他的服务器
- 有了多个数据副本后，就可以使请求数据分流，减少单台服务器的压力

但也带来了问题，一致性问题：这个副本可能与另一个副本不一致。例如：值X在节点M和N上都有副本，客户端A
修改了M上的X，过了一段时间后，客户端B在N上看到的值是什么值？

进一步将这个问题扩展：
- 客户端A修改了好多次M上的X
- 进一步细分时间
- ...

根据上面的问题就引入了一致性模型
## 一致性模型
[不同的资料](https://zhuanlan.zhihu.com/p/58952564)中对于一致性模型的解释并不是完全一样的。


### 以数据为中心的一致性#
综合现有的资料，一致性模型有以下几种，按我的理解将其与不同的时钟对应
- Strict一致性，物理时钟（绝对全局时钟）
- Linearizability一致性，全局时钟
- Sequential一致性，逻辑时钟
- Casual一致性，向量时钟
- FIFO一致性
- Weak一致性
- Release一致性
- Entry一致性




### 以客户端为中心的一致性（Client-centric Consistency）
前面我们讨论的一致性模型都是针对数据存储的多副本之间如何做到一致性，考虑这么一种场景：

```note
在最终一致性的模型中，如果客户端在数据不同步的时间窗口内访问不同的副本的同一个数据，会出现读取同一个数据却得到不同的值的情况。
为了解决这个问题，有人提出了以客户端为中心的一致性模型。
以客户端为中心的一致性为单一客户端提供一致性保证，保证该客户端对数据存储的访问的一致性，但是它不为不同客户端的并发访问提供任何一致性保证。 
```

举个例子：客户端 A 在副本 M 上读取 x 的最新值为 1，假设副本 M 挂了，客户端 A 连接到副本 N 上，此时副本 N 上面的 x 值为旧版本的 0，那么一致性模型会**保证客户端 A 读取到的 x 的值为 1，而不是旧版本的 0**。一种可行的方案就是给数据 x 加版本标记，同时客户端 A 会缓存 x 的值，通过比较版本来识别数据的新旧，保证客户端不会读取到旧的值。

以客户端为中心的一致性包含了四种子模型：

- 单调读一致性（Monotonic-read Consistency）：
    如果一个进程读取数据项 x 的值，那么该进程对于 x 后续的所有读操作要么读取到第一次读取的值要么读取到更新的值。即保证客户端不会读取到旧值。
- 单调写一致性（Monotonic-write Consistency）：
    一个进程对数据项 x 的写操作必须在该进程对 x 执行任何后续写操作之前完成。即保证客户端的**写操作是串行的**。
- 读写一致性（Read-your-writes Consistency）：
    一个进程对数据项 x 执行一次写操作的结果总是会被该进程对 x 执行的后续读操作看见。即保证客户端**能读到自己最新写入的值**。
- 写读一致性（Writes-follow-reads Consistency）：
    同一个进程对数据项 x 执行的读操作之后的写操作，保证发生在与 x 读取值相同或比之更新的值上。即保证客户端**对一个数据项的写操作是基于该客户端最新读取的值**。


## 一致性协议
Primary-based protocols 

Replicated write protocols

Cache-coherence protocols